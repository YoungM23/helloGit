# 1.**自我介绍**

尊敬的面试官，您好！我叫张清辉。

在过去的工作中，我积累了丰富的 Java 开发经验，具备扎实的专业技能和良好的职业素养。 在专业技能方面，我精通 Java 语言及面向对象设计，熟悉主流 Java Web 框架及其设计原理，包括 MyBatis、Spring、SpringMVC、SpringBoot、MybatisPlus、Swagger、Shiro 等开发框架。

我对关系型数据库 MySQL 和 Oracle 也非常熟悉，擅长 SQL 语言，具备系统数据库设计和规划能力。此外，我还熟悉 Vue 前端框架、使用过Echarts 图表以及 element-ui、Vue-amap 等组件库。在过去的项目中， Git 和 Svn 的版本控制都使用过。

熟悉 Unix/Linux 操作系统和开发环境。使用过 RabbitMQ、RocketMQ 等主流消息队列，熟悉缓存技术和异步框架，有比较还不错的逻辑思维能力，能够快速高效地修复系统缺陷，对代码进行单元测试，确保系统稳定运行。 

我的学习能力也是比较强的，能够快速掌握新技术，适应新环境。能够在压力下保持高效工作状态，具备良好的抗压能力和沟通能力。



另外我的英语能力也不错，大学的时候过了英语4级。平常也喜欢在youtobe上看些英语视频提升英语。英语可以作为工作语言，能够无障碍阅读英文文档。 

在工作经历方面，我在上家公司担任 Java 开发工程师。在这个岗位上，我负责了关键模块的代码编写与维护，参与搭建了公司自有软件框架，进行了第三方中间件的选型，独立进行了单元测试，快速高效地修复了系统缺陷。

看到贵公司的招聘信息，觉得自己比较符合公司要求，希望能够有机会加入贵公司。

---

我还参与了山东临工 DMS 经销商管理系统、致远 A8+协同管理系统、万象城客户管理系统、大通集团罗江天然气分公司工程管理系统、成都道勤数控刀具进销存管理系统等多个项目的开发，在项目中负责了服务模块开发、系统二次开发、核心模块开发、合同管理模块开发等工作，取得了显著的项目成绩。 我认为我非常符合贵公司的岗位要求。我有 5 年的 Java 开发经验，对 JVM 有较深理解，有 JVM 性能调优相关经验，了解并能够应用常用设计模式，有微服务框架经验。我熟悉 SpringCloud 的配置技术和工作原理，有一定的 SQL 性能调优经验，对其内部原理有深刻理解，熟悉 redis、RabbitMQ、kafka 等常用中间件，有良好的代码习惯，注重代码质量，具备独立解决问题的能力和团队合作精神，思路清晰，善于思考，责任心强，善于沟通，具备较强的团队协作意识和能力。 非常感谢您给我这个机会介绍自己，我期待能加入贵公司，为公司的发展贡献自己的力量。

# 2.**在团队协作方面，能否分享一个你与团队成员成功解决问题的案例呢？**

在团队协作方面，在致远 A8 + 协同管理系统项目中，我们遇到了一个紧急的 bug，影响了客户的正常使用。我们团队成员迅速响应，一起分析问题的原因。通过**分工合作**，一部分人负责查**看日志和分析代码**，另一部分人负责与**客户沟通了解具体情况**。最后，我们确定了问题是由于一个数**据库查询语句的性能**问题导致的。我们共同讨论解决方案，对查询语句进行了优化，并进行了充分的测试。通过这次事件，我们不仅及时解决了客户的问题，也增强了团队的凝聚力和协作能力。

# 3.在你参与的多个项目中，哪个项目让你印象最为深刻？为什么？



## 回答：

在我参与的项目中，山东临工 DMS 经销商管理系统让我印象最为深刻。这个项目涉及到**多个复杂的业务模块**，对系统的**性能和稳定性**要求非常高。在项目中，我不仅负责了服务相关模块的开发与维护，还参与了系统的性能优化和技术落地工作。通过这个项目，我积累了丰富的高并发、微服务和分布式系统的开发经验，也提升了自己解决复杂问题的能力。



# JVM问题

##  **JVM 性能调优方面的具体经验吗**?

【在介绍 JVM 性能调优经验时，可以更加具体地阐述遇到的问题场景，比如是在高并发情况下出现内存溢出，还是垃圾回收不及时导致系统卡顿等，然后详细说明你采取的具体调优措施，例如调整内存参数、选择合适的垃圾回收器等。】

 回答：

在 JVM 性能调优方面，我曾在项目中遇到过内存溢出的问题。当时系统在高并发情况下运行一段时间后，出现了 OutOfMemoryError。我首先通过分析内存快照，确定是某些对象没有被及时回收导致内存占用过高。然后，我调整了 JVM 的内存参数，**增加了堆内存的大小**，并优化了对象的创建和回收逻辑。同时，我还选择了更适合项目场景的垃圾回收器，以提高垃圾回收的效率。经过这些调整，系统的稳定性得到了显著提升。 



- 自己的回答

1. **在OA项目中，有一次客服反应OA系统崩了**，我们紧急排查问题，发现是内存溢出了。通过系统启动的jvm参数中，**最大堆空间**设置过小，只有4个G，而OA系统运行需要更大一点的空间。结合服务器情况，当时这台服务器的内存是16个G,考虑到这台服务只是用来部署OA系统，预留一些内存空间给操作系统和jvm中的栈等，最后修改最大堆空间为10G。后期客户系统运行正常。
2. 还有次出现过类似情况，也是内存溢出问题，但是这次我们通过日志（在jvm启动参数中设置了-XX+HeapDumpOnOutOfMemeryError，在内存溢出时生成了dump文件。使用**visualVM**去查看dump文件，排查出现问题的堆栈）排查到代码中出现了一个死循环。这个是属于代码逻辑问题，通过修改代码紧急上线解决问题。
3. oa项目中，客户反应表单提交时，长时间卡顿。通过**jstack**在回显问题时候，获取抓取线程快照，发现长时间运行的线程，最后通过堆栈定位到问题。

## JVM 的主要组成部分及其功能：

- 类加载器（ClassLoader）：负责加载字节码文件到 JVM 中，可分为启动类加载器、扩展类加载器和应用程序类加载器等，不同的类加载器有不同的加载范围和优先级。
- 运行时数据区：包括堆（Heap），用于存储对象实例；栈（Stack），每个线程都有自己的栈，用于存储局部变量表、操作数栈、动态链接、方法出口等信息；方法区（Method Area），存储已被虚拟机加载的类信息、常量、静态变量等；程序计数器（Program Counter Register），记录当前线程执行的字节码行号指示器。
- 执行引擎（Execution Engine）：负责执行字节码指令。

## 堆内存分为哪几个区域？

- 新生代
  - Eden区和survivor区
- 老年代

**新创建的对象通常先分配在 Eden 区**，经过垃圾回收后存活的对象会在 Survivor 区之间移动或者晋升到老年代。



## 如何判断一个对象是否可以被垃圾回收？

- 引用计数法：给对象添加一个**引用计数器**，当有引用指向它时计数器加 1，当引用失效时计数器减 1，当计数器为 0 时表示对象可被回收，但这种方法无法解决循环引用的问题。
- 可达性分析算法：**以一系列被称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索**，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连（即不可达）时，则证明此对象是可被回收的。GC Roots 包括虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象等。

Java8默认使用什么垃圾收集器：

默认使用并行垃圾收集器，parallel GC，分为新生代和老年代

## JVM的垃圾回收算法

- 复制算法
- 标记清除算法
- 标记整理算法



## 内存溢出和内存泄漏的关系：

是一个因果关系，内存泄漏可能是因为代码中存在死循环，导致需要不断的申请内存。或者创建的对象不再使用了，但是无法被回收，最后导致内存溢出。

如果是内存泄漏到导致的内存溢出，需要调整代码逻辑。如果不是，可能需要重新调整jvm的参数，给堆空间分配一个合理的内存大小。

## JVM常用启动参数：

- -Xms
  - 含义：**设置 JVM 初始堆内存大小**。
  - 示例：`-Xms512m`，表示 JVM 启动时初始堆内存为 512MB。这一参数确保 JVM 在启动时就分配指定大小的内存，避免在运行过程中频繁扩展内存空间带来的性能开销。
- -Xmx
  - 含义：**设置 JVM 最大堆内存大小**。
  - 示例：`-Xmx2g`，将 JVM 最大堆内存限制为 2GB。合理设置此参数可以防止 JVM 因内存过度使用而导致系统内存耗尽。
- -Xmn
  - 含义：**设置年轻代（Young Generation）大小**。年轻代是堆内存的一部分，主要用于存放新创建的对象。
  - 示例：`-Xmn256m`，指定年轻代大小为 256MB。调整年轻代大小可以优化垃圾回收性能，因为年轻代中的对象生命周期较短，频繁的垃圾回收操作主要发生在年轻代。
- -XX:+UseG1GC
  - 含义：**启用 G1（Garbage - First）垃圾回收器**。G1 是一种面向服务端应用的垃圾回收器，它将堆内存划分为多个大小相等的区域（Region），在垃圾回收时优先回收垃圾最多的区域，能提供可预测的停顿时间，并且在处理大内存时性能较好。

## 设置堆空间最大值（-Xmx）需要考虑的因素：

大概设置系统内存的70%左右，因为操作系统运行会占用一部分内存，栈空间等还需要一部分内存空间。

## 双亲委派机制：

除去顶层的类加载器，其他类加载器在加载的时候都会询问其父类加载器，该类是否已经加载过了。

**优点**

- 避免Java的核心类被修改
- 避免类的重复加载



## JVM性能调优类问题

### JVM 性能调优常见工具

- JConsole：是一个 **Java 监视和管理控制台**，可以用于监控 JVM 的性能指标，如内存使用情况、线程状态等。 
- VisualVM：它集成了多个 JDK 命令行工具的功能，能够监控和分析 JVM 的运行时数据，包括内存泄漏检测、性能瓶颈分析等。 
- jmap：**用于生成堆转储快照**，可以查看堆内存中的对象分布情况，帮助分析内存溢出等问题。 
- jstack：用于生成当前时刻的**线程快照**，可用于分析线程死锁、线程长时间停顿等问题。

### 频繁的 Full GC，可能的原因有哪些？如何解决？

- 可能的原因：
  - 老年代空间不足，可能是因为对象晋升到老年代的速度过快，例如大对象直接进入老年代或者长期存活的对象过多。
  - 内存泄漏，存在对象被错误引用无法被回收，导致老年代空间被占用。
  - 不合理的堆内存设置，例如老年代和新生代的比例不合适。
- 解决方法：
  - 优化对象的生命周期管理，减少不必要的对象创建，尤其是大对象。
  - 检查代码中是否存在内存泄漏，通过分析堆转储快照查找可能的泄漏点。
  - 根据实际情况调整堆内存参数，如增大老年代空间或者调整新生代与老年代的比例。

# 微服务SpringCould



## 不同服务之间的通信方式

1.通过接口通信，微服务使用feign组件在不同服务间方便调用接口

2.MQ消息队列，异步和解耦



## 1.**对于 SpringCloud 的配置技术和工作原理，你能举一个具体的例子来说明你是如何应用的吗？**

建议：

对于 SpringCloud 的配置技术和工作原理，可以准备一些实际项目中的例子，比如如何通过配置实现服务注册与发现、负载均衡等，这样能更好地展示你对该技术的掌握程度。

回答：

对于 SpringCloud 的配置技术和工作原理，在山东临工 DMS 经销商管理系统中，我们通过 SpringCloud 的服务注册与发现功能，实现了系统的微服务架构。具体来说，我们使用了 Eureka 作为服务注册中心，各个微服务在启动时会向 Eureka 注册自己的服务信息，当其他服务需要调用某个服务时，只需要从 Eureka 中获取该服务的地址信息即可。这样可以实现服务的动态发现和负载均衡，提高了系统的可扩展性和可靠性。

## 2.Eureka和Nacos注册中心的区别：

- Nacos支持服务的注册和发现，以及配置管理，Eureka没有
- Nacos的社区活跃度更高，使用更多。
- Eureka的资源占用更少，因为Nacos的功能更多，所以相对资源占用更多

## 有哪些组件

- Nacos，Eureka
- SpringCloudConfig服务配置 
- feign
- gateway
- Ribbon负载均衡
- Sentinel服务保护组件



## 分布式事务

## mq消息丢失



发送确认机制：一些 MQ 提供了发送确认机制，生产者发送消息后，等待 Broker 返回确认消息。如果在一定时间内未收到确认消息，则进行重试。

消息的持久化配置

如果消息是在消费者那里丢失的话，那就可以采用消费者的消息手动确认机制。当消费者将消息消费以后，再向broker确认。

## mq消息重复消费



**消息去重表：**在数据库中创建一个消息去重表，记录已经处理过的消息的唯一标识。消费者在处理消息前，先查询去重表，如果该消息已经处理过，则直接忽略。

**使用 Redis 缓存**：将消息的唯一标识存储在 Redis 中，设置一定的过期时间。消费者在处理消息前，先检查 Redis 中是否存在该消息的标识，如果存在则忽略，不存在则处理消息并将标识存入 Redis。

# 数据库

## 如何应用 MyBatis 框架进行数据库操作

在实际项目中，对于数据查询，我会使用 MyBatis 的 XML 映射文件来定义 SQL 语句，并通过 Java 对象传递参数。例如，使用`<select>`标签定义查询语句，通过`#{参数名}`的方式接收传入的参数，然后在 Java 代码中调用对应的 Mapper 接口方法来执行查询操作，将查询结果映射为 Java 对象返回。

对于数据插入，使用`<insert>`标签定义插入语句，同样可以传入参数进行动态插入。在插入操作时，还可以通过配置返回自增主键的值，方便后续操作。

更新和删除操作类似，使用`<update>`和`<delete>`标签定义相应的 SQL 语句，并传入参数执行操作。

在处理事务方面，通常会在 Spring 框架中配置事务管理器，然后在需要事务的方法上添加`@Transactional`注解，确保一系列数据库操作要么全部成功提交，要么全部回滚。例如在业务逻辑复杂的服务模块开发中，涉及多个数据库操作时，通过这种方式保证数据的一致性。

## SQL 性能进行调优经验

- 首先，**合理使用索引**。在经常用于查询条件的字段上创建索引，提高查询速度。例如在DMS系统中，针对客户编号、客户名称等字段创建索引，大大提高了查询特定客户信息的速度。
- 其次，**避免全表扫描**。通过优化查询语句，确保查询只涉及**必要的字段和数据范围**，减少不必要的数据读取。比如使用`WHERE`子句精确限定查询条件。
- 另外，对于复杂的查询，可以考虑使用**临时表**或者视图来简化查询逻辑，提高性能。在工程管理系统中，通过创建临时表来存储中间结果，然后对临时表进行查询，提高了复杂统计查询的性能。
- 不能在代码的循环中操作数据库

## SQL语句优化

- 使用`EXISTS`代替`IN`

- 避免复杂的嵌套查询和全表扫描

- 将多个关联查询进行合理的拆分和优化

- 需要多次插入、更新或查询数据库的操作，尽量采用批量操作的方式

- `BETWEEN`比使用多个`AND`条件可能更高效

- 通常使用小表连接大表更为高效

- 不同的数据库有不同的存储引擎，如 MySQL 中的 InnoDB 和 MyISAM

  



## **棘手技术难题及解决方法**

在参与的项目中，曾经遇到过系统在高并发情况下性能下降严重的问题。经过分析，发现是**数据库连接数过多**，导致数据库响应缓慢。

解决方法是：

- 一方面，优化数据库连接池的配置，**调整最大连接数**、最小连接数等参数，确保在高并发情况下能够合理分配数据库连接资源。
- 另一方面，对一些频繁执行的**数据库操作进行缓存**，减少对数据库的直接访问。
- 同时，对一些耗时的业务逻辑进行异步处理，提高系统的响应速度。
- 设置合理的**连接超时时间**。如果一个连接请求在一定时间（如 30 秒）内无法获取到连接，就让其超时并返回错误信息，而不是无限期等待。这样可以避免连接请求堆积，导致系统资源被长时间占用。

## 处理大数据量的一些经验

- 首先是**优化查询语句**
- 必要的时候进行**分库分表**
- **读写分离**，读操作通常远远多于写操作。通过建立主从数据库，将写操作指向主库，读操作分配到从库
- 使用**缓存**，比如redis
- 代码采用异步处理
  - 在处理大数据量相关业务时，采用异步处理方式可以提高系统的并发处理能力。例如在一个文件上传系统中，当用户上传大文件时，先将文件信息保存到数据库（快速操作），然后在后台异步进行文件的存储和处理（可能涉及对文件内容的解析、数据提取等大数据量操作），这样用户可以继续进行其他操作，而不会因为文件处理时间过长而等待。

## 

## 当单表数据量达到多大的时候，需要分表？

## 读写分离的主从数据库如何做到一致性？

# ES

## 简介

全文检索的工具，索引就类似于数据库表，文档就是一条数据。

**倒排索引：**

1.文档字段的值先进行分词，存入列表，分别存入分词后的词条和id。

2.搜索的时候，先对搜索内容进行分词。

3.用分词后的词条去列表中匹配，匹配成功后获取id，再根据id去查找文档数据。

4.获取的id可能是多个，这就类似于模糊查找。

## es与数据库的对比

| 数据库     | es           |
| ---------- | ------------ |
| 表         | 索引index    |
| 数据       | 文档document |
| 约束schema | 字段定义     |
|            |              |



## 索引的CURD

## 文档的CURD

新增：POST/索引/_doc/id

修改：全量修改：PUT/索引/_doc/id,  部分修改：POST/索引/_update/id

查询：GET/索引/_doc/id

删除：DELETED/索引/_doc/id



## 索引设计

- 不必要的字段，不放进索引中
- 不需要搜索的字段，不要进行分词，设置成keyword类型 
- 大字段类的，不要进行分词 

## 查询优化

## 性能调优

## 分片

# MQ

## 消息丢失如何解决

- 持久化消息
- 消息生产者发送确认机制
- 事务机制
- rabbitmq高可用集群配置
- 消费者消息确认机制

# 多线程

## 线程池

### 线程池参数

- 核心线程数：线程池中的固定线程，不会销毁
- 最大线程数：核心线程数+临时线程数
- 存活时间：临时线程在没有使用的情况下，可以保持存活的时间
- 存活时间单位
- 拒绝策略：当需要的线程数，大于最大线程数+队列大小的时候，使用什么方式拒绝申请线程的请求
- 线程工厂：创建线程的工厂类
- 线程队列

## 线程使用顺序

1. 核心线程
2. 进入队列
3. 创建临时队列
4. 最后拒绝策略

# **未来技术发展规划**

- 新技术
- 紧跟AI

#  



#  